# 虚拟机栈基本内容

## 介绍

由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。

优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

有不少Java开发人员一提到Java内存结构,就会非常粗粒度地将JM中的内存区理解为仅有Java堆(heap)和Java栈( stack)?为什么?

**栈是运行时的单位,而堆是存储的单位。**

即：
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。
堆解决的是数据存储的问题，即数据怎么放、放在哪儿。



Java虚拟机栈是什么?

Java虚拟机栈( Java virtual Machine stack),早期也叫Java栈。
**每个线程**在创建时都会创建一个虚拟机栈,其内部保存一个个的栈帧( Stack frame),对应着一次次的Java方法调用。

是线程私有的

生命周期生命周期和线程一致。

**作用**：主管Java程序的运行,它保存方法的局部变量、部分结果，并参与方法的调用和返回。

局部变量：8种基本数据类型、对象的引用地址

**举例**

![](虚拟机栈.assets/虚拟机栈举例.svg)

**栈的特点**

栈是一种快速有效的分配存储方式,访问速度仅次于程序计数器。

JVM直接对Java栈的操作只有两个：

- 每个方法执行，伴随着进栈(入栈、压栈)
- 执行结束后的出栈工作

对于栈来说不存在垃圾回收问题，但存在OOM

![](虚拟机栈.assets/压栈和出栈.svg)

## 栈中可能出现的异常

Java虚拟机规范允许**Java栈的大小是动态的或者是固定不变的**。

如果采用固定大小的Java虚拟机栈,那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量,Java虚拟机将会抛出一个**StackoverFlowError**异常。

如果Java虚拟机栈可以动态扩展,并且在尝试扩展的时候无法申请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈,那Java虚拟机将会抛出一个 **OutOfMemoryError**异常。



## 设置栈内存大小

我们可以使用参数-Xss选项来设置线程的最大栈空间,栈的大小直接决定了函数调用的最大可达深度。

```java
/**
 * 演示栈中的异常:StackOverflowError
 * @author shkstart
 * @create 2020 下午 9:08
 *
 *  默认情况下：count : 11420
 *  设置栈的大小： -Xss256k : count : 2465
 */
public class StackErrorTest {
    private static int count = 1;
    public static void main(String[] args) {
        System.out.println(count);
        count++;
        main(args);
    }
}
```



# 栈的结构

## 栈中存储什么？

每个线程都有自己的栈，栈中的数据都是以**栈帧(** Stack Frame)的格式存在。
在这个线程上正在执行的每个方法都各自对应一个栈帧( Stack Frame)。
栈帧是一个内存区块,是一个数据集,维系着方法执行过程中的各种数据信息。

JVM直接对Java栈的操作只有两个,就是对栈帧的压栈和出栈,遵循“先进后出”/“后进先出”原则。

在一条活动线程中,一个时间点上,只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的,这个栈帧被称为**当前栈帧**( Current frame),与当前栈帧相对应的方法就是**当前方法**( CurrentMethod),定义这个方法的类就是**当前类**( Current class)。

执行引擎运行的所有字节码指令只针对当前栈帧进行操作。如果在该方法中调用了其他方法,对应的新的栈帧会被创建出来,放在栈的顶端,成为新的当前帧。

![](虚拟机栈.assets/栈帧的结构.svg)

## 栈的运行原理

不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

如果当前方法调用了其他方法,方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。

Java方法有两种返回函数的方式，**一种是正常的函数返回,使用 return指令;另外一种是抛出异常**。**不管使用哪种方式,都会导致栈帧被弹出。**

## 栈帧的内部结构

每个栈帧中存储着:

- **局部变量表**(Local Variables)

- **操作数栈**( Operand Stack) (或表达式栈)
- 动态链接( Dynamic Linking) (或指向运行时常量池的方法引用)
- 方法返回地址( Return Address) (或方法正常退出或者异常退出的定义
- 一些附加信息

![](虚拟机栈.assets/栈帧的结构.svg)

线程和栈帧：

![](虚拟机栈.assets/栈帧和线程.svg)

# 局部变量表

- 局部变量表也被称之为局部变量数组或地变量表

- **定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**，这些数据类型包括各类基本数据类型、对象引用( reference)，以及returnAddress类型。
- 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
- **局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的code属性的 maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。

https://www.bilibili.com/video/BV1PJ411n7xZ?p=48

