{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)"},"children":[{"parent":"9f4f50349524","children":[{"parent":"531cde8077d2","children":[],"id":"093f636c50bf","title":"最常见的方式"},{"parent":"531cde8077d2","children":[],"id":"34f145153f9e","title":"变形1：Xxx的静态方法"},{"parent":"531cde8077d2","children":[],"id":"043e7dd7bdb9","title":"变形2：XxxBuilder/XxxFactory的静态方法"}],"id":"531cde8077d2","title":"new"},{"parent":"9f4f50349524","children":[],"id":"aa9d790c4c46","title":"Class的newInstance()：反射的方式，只能调用空参构造器，权限必须是public"},{"parent":"9f4f50349524","children":[],"id":"6ee4e6954b42","title":"Constructor的newInstance(Xxx)：反射的空参：可以调用空参、带参的构造器，权限没有要求"},{"parent":"9f4f50349524","children":[],"id":"9ed93665fcff","title":"使用clone()：不调用任何构造器，当前类需要实现Cloneable接口，实现clone()"},{"parent":"9f4f50349524","children":[],"id":"e497ff336f29","title":"使用反序列化：从文件中、网络中获取对象的二进制流"},{"parent":"9f4f50349524","children":[],"id":"f1ce7fb7091c","title":"第三方库Objenesis"}],"id":"9f4f50349524","title":"创建对象的方式"},{"parent":"root","children":[{"parent":"3c814f478555","note":"虚拟机遇到一条new指令，首先去检查这个指令的参数能否在 Metaspace的常量池中定位到一个类的符号引用，并面检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有，那么在双亲要派模式下，使用当前类加载器以 ClassLoader+包名+类名为Key进行查找对应的 class文件，如果没有找到文件，则抛出 ClassNotFoundException异常，如果找到，则进行类加载,并生成对应的class类对象","children":[],"id":"b3e55d0c41d7","title":"1.判断对象对应的类是否加载、链接、初始化"},{"parent":"3c814f478555","note":"首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。**如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。**即，分配内存时，看对象中成员属性的类型就能知道改对象占用的内存大小。","children":[{"parent":"e855de50e497","note":"如果内存是规整的，那么虚拟机将采用的是指针碰撞法(Bumpp The Pointer)来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial、 ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有 compact(整理)过程的收集器时，使用指针碰撞。","children":[],"id":"4ee7045da8a0","title":"如果内存规整"},{"parent":"e855de50e497","children":[{"parent":"685cb85b15fb","children":[],"id":"bc2f0b943589","title":"虚拟机需要维护一个列表"},{"parent":"685cb85b15fb","note":"如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表( Free List)”","children":[],"id":"261c4ae6eb8f","title":"空闲列表分配"}],"id":"685cb85b15fb","title":"如果内存不规整"},{"parent":"e855de50e497","note":"选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。","children":[],"id":"5473a4f2c0be","title":"说明"}],"id":"e855de50e497","title":"2.为对象分配内存"},{"parent":"3c814f478555","children":[{"parent":"7c0d22cda768","children":[],"id":"265012b00be3","title":"采用CAS配上失败重试保证更新的原子性"},{"parent":"7c0d22cda768","children":[{"parent":"582fa2c8a344","children":[],"id":"6f56180b72ea","title":"通过-XX:+/-UseTLAB参数来设定"}],"id":"582fa2c8a344","title":"每个线程预先分配一块TLAB"}],"id":"7c0d22cda768","title":"3.处理并发安全问题"},{"parent":"3c814f478555","children":[{"parent":"4b72d43e80e3","children":[],"id":"5a94b7b92d0b","title":"所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用"}],"id":"4b72d43e80e3","title":"4.初始化分配到的空间"},{"parent":"3c814f478555","note":"将对象的所属类(即类的元数据信息)、对象的 HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。","children":[],"id":"40c1bdcff514","title":"5.设置对象的头"},{"parent":"3c814f478555","note":"在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说(由字节码中是否跟随有 invokespecial指令所决定)，new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。","children":[],"id":"99fdc13429c0","title":"6.执行init方法进行初始化"}],"id":"3c814f478555","title":"创建对象的步骤"}],"root":true,"theme":"theme3_1","id":"root","title":"对象的实例化","structure":"mind_free"}},"meta":{"exportTime":"2022-03-19 22:29:16","member":"5f2549977d9c0835d3a0958d","diagramInfo":{"creator":"5f2549977d9c0835d3a0958d","created":"2022-03-19 21:31:31","modified":"2022-03-19 22:28:54","title":"对象的实例化","category":"mind_free"},"id":"6235db331e085306f8c356c8","type":"ProcessOn Schema File","version":"1.0"}}